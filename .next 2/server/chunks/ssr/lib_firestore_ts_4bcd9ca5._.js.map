{"version":3,"sources":["../../../../lib/firestore.ts"],"sourcesContent":["\"use client\"\n\nimport { \n  collection, \n  doc, \n  addDoc, \n  updateDoc, \n  deleteDoc, \n  getDocs, \n  getDoc, \n  query, \n  where, \n  orderBy, \n  onSnapshot,\n  serverTimestamp,\n  Timestamp,\n  setDoc\n} from \"firebase/firestore\"\nimport { ref, uploadBytes, getDownloadURL } from \"firebase/storage\"\nimport { db, storage } from \"./firebase\"\n\n// Types\nexport interface MaterialFolder {\n  id: string\n  name: string\n  color: string\n  userId: string\n  createdAt: Date\n}\n\nexport interface Material {\n  id: string\n  title: string\n  type: \"pdf\" | \"image\" | \"text\" | \"other\"\n  subject: string\n  fileUrl?: string\n  content?: string\n  folderId?: string\n  userId: string\n  createdAt: Date\n}\n\n// Legacy Flashcard interface (for backward compatibility)\nexport interface Flashcard {\n  id: string\n  front: string\n  back: string\n  difficulty: \"easy\" | \"medium\" | \"hard\"\n  deckId: string\n  userId: string\n  createdAt: Date\n  lastReviewed?: Date\n  nextReview?: Date\n  reviewCount?: number\n  easeFactor?: number\n}\n\n// ==================== EXAM-GRADE FLASHCARD TYPES ====================\n\nexport type FlashcardType = \"definition\" | \"why\" | \"how\" | \"compare\" | \"trap\" | \"example\" | \"exam\"\nexport type FlashcardDifficulty = \"beginner\" | \"intermediate\" | \"advanced\" | \"expert\"\nexport type SRSRating = \"again\" | \"hard\" | \"good\" | \"easy\"\n\nexport interface ExamGradeFlashcard {\n  id: string\n  type: FlashcardType\n  question: string\n  answer: string\n  difficulty: FlashcardDifficulty\n  topic: string\n  subtopic?: string\n  source: string\n  exam_relevance: number // 1-10\n  key_terms: string[]\n  mistake_prone: boolean\n  \n  // Firestore fields\n  deckId: string\n  userId: string\n  createdAt: Date\n  \n  // SRS fields\n  lastReviewed?: Date\n  nextReview?: Date\n  reviewCount: number\n  correctCount: number\n  incorrectCount: number\n  interval: number  // days until next review\n  easeFactor: number  // 1.3 to 2.5\n  consecutiveCorrect: number\n  \n  // Mistake tracking\n  mistakeHistory: MistakeRecord[]\n}\n\nexport interface MistakeRecord {\n  date: Date\n  wrongAnswer?: string\n  correctAnswer: string\n  timeSpent?: number  // seconds\n}\n\nexport interface ExamGradeFlashcardDeck {\n  id: string\n  name: string\n  subject: string\n  topic: string\n  cardCount: number\n  userId: string\n  createdAt: Date\n  \n  // Enhanced metadata\n  totalCards: number\n  masteredCards: number  // cards with interval > 21 days\n  dueCards: number\n  avgExamRelevance: number\n  cardTypeDistribution: Record<FlashcardType, number>\n  difficultyDistribution: Record<FlashcardDifficulty, number>\n  \n  // Study stats\n  lastStudied?: Date\n  totalReviews: number\n  avgAccuracy: number\n}\n\nexport interface FlashcardDeck {\n  id: string\n  name: string\n  subject: string\n  cardCount: number\n  userId: string\n  createdAt: Date\n}\n\nexport interface StudyTask {\n  id: string\n  planId: string\n  day: number\n  title: string\n  completed: boolean\n  hours: number\n  dueDate: Date\n  userId: string\n  priority: \"low\" | \"medium\" | \"high\"\n  status: \"pending\" | \"in-progress\" | \"completed\"\n}\n\nexport interface StudyPlan {\n  id: string\n  name: string\n  subject: string\n  examDate: Date\n  difficulty: \"easy\" | \"medium\" | \"hard\"\n  hoursPerDay: number\n  userId: string\n  createdAt: Date\n  completedTasks: number\n  totalTasks: number\n}\n\nexport interface GroupMember {\n  userId: string\n  displayName: string\n  email: string\n  role: \"admin\" | \"member\"\n  joinedAt: Date\n  avatarUrl?: string\n}\n\nexport interface StudyGroup {\n  id: string\n  name: string\n  subject: string\n  description: string\n  members: GroupMember[]\n  memberCount: number\n  createdBy: string\n  createdAt: Date\n  maxMembers?: number\n  isPrivate?: boolean\n}\n\nexport interface GroupMessage {\n  id: string\n  groupId: string\n  content: string\n  userId: string\n  userName: string\n  createdAt: Date\n}\n\nexport interface BookmarkedJob {\n  id: string\n  jobId: string\n  title: string\n  company: string\n  location: string\n  deadline: string\n  type: string\n  url: string\n  userId: string\n  createdAt: Date\n}\n\n// Assistant Conversation\nexport interface ConversationMessage {\n  role: \"user\" | \"assistant\"\n  content: string\n  timestamp: Date\n}\n\nexport interface Conversation {\n  id: string\n  userId: string\n  title: string\n  messages: ConversationMessage[]\n  context?: {\n    materialIds?: string[]\n    deckIds?: string[]\n    planIds?: string[]\n  }\n  createdAt: Date\n  updatedAt: Date\n}\n\n// Assistant Memory (for \"remember that...\" commands)\nexport interface Memory {\n  id: string\n  userId: string\n  content: string\n  category: \"note\" | \"reminder\" | \"fact\" | \"preference\"\n  relatedEntities?: string[]\n  createdAt: Date\n}\n\n// ==================== ENHANCED TASK SYSTEM ====================\nexport interface Task {\n  id: string\n  userId: string\n  title: string\n  description?: string\n  priority: \"low\" | \"medium\" | \"high\" | \"urgent\"\n  status: \"todo\" | \"in-progress\" | \"done\" | \"blocked\"\n  tags: string[] // e.g., [\"DSA\", \"project\", \"CP\", \"gym\"]\n  course?: string\n  topic?: string\n  type?: \"Assignment\" | \"Revision\" | \"Practice\" | \"Reading\" | \"Project\" | \"Exam Prep\" | \"Other\"\n  difficulty?: \"Easy\" | \"Medium\" | \"Hard\"\n  estimatedMinutes: number\n  actualMinutes?: number\n  dueDate?: Date\n  scheduledDate?: Date\n  scheduledStartTime?: string // \"14:00\"\n  scheduledEndTime?: string // \"16:00\"\n  subtasks: Subtask[]\n  links?: TaskLink[]\n  completedAt?: Date\n  createdAt: Date\n  updatedAt: Date\n}\n\nexport interface Subtask {\n  id: string\n  title: string\n  completed: boolean\n}\n\nexport interface TaskLink {\n  type: \"github\" | \"leetcode\" | \"codeforces\" | \"document\" | \"other\"\n  url: string\n  label?: string\n}\n\n// ==================== CALENDAR & EVENTS ====================\nexport interface CalendarEvent {\n  id: string\n  userId: string\n  title: string\n  type: \"class\" | \"lab\" | \"exam\" | \"assignment\" | \"meeting\" | \"focus\" | \"break\" | \"other\" | \"study-session\" | \"contest\"\n  course?: string\n  description?: string\n  location?: string\n  startTime: Date\n  endTime: Date\n  isAllDay: boolean\n  isRecurring: boolean\n  recurrence?: {\n    frequency: \"daily\" | \"weekly\" | \"biweekly\" | \"monthly\"\n    daysOfWeek?: number[] // 0-6, Sunday-Saturday\n    endDate?: Date\n    exceptions?: Date[] // Dates to skip\n  }\n  color?: string\n  reminders?: number[] // Minutes before event\n  meetingLink?: string\n  isOnline?: boolean\n  createdAt: Date\n}\n\n// ==================== TIME BLOCKS & POMODORO ====================\nexport interface TimeBlock {\n  id: string\n  userId: string\n  taskId?: string\n  title: string\n  type: \"deep-work\" | \"shallow-work\" | \"break\" | \"meeting\" | \"personal\"\n  startTime: Date\n  endTime: Date\n  completed: boolean\n  actualDuration?: number // minutes\n  notes?: string\n  createdAt: Date\n}\n\nexport interface PomodoroSession {\n  id: string\n  userId: string\n  taskId?: string\n  course?: string\n  startTime: Date\n  endTime?: Date\n  plannedDuration: number // minutes\n  actualDuration?: number\n  type: \"work\" | \"short-break\" | \"long-break\"\n  completed: boolean\n  interrupted: boolean\n  productivityRating?: number // 1-5\n  notes?: string\n}\n\nexport interface PomodoroSettings {\n  userId: string\n  workDuration: number // default 25\n  shortBreakDuration: number // default 5\n  longBreakDuration: number // default 15\n  sessionsBeforeLongBreak: number // default 4\n  autoStartBreaks: boolean\n  autoStartWork: boolean\n  soundEnabled: boolean\n  notificationsEnabled: boolean\n}\n\n// ==================== ANALYTICS & TRACKING ====================\nexport interface StudySession {\n  id: string\n  userId: string\n  taskId?: string\n  course?: string\n  tags: string[]\n  startTime: Date\n  endTime: Date\n  duration: number // minutes\n  productivityRating?: number // 1-5\n  difficultyRating?: number // 1-5\n  notes?: string\n  pomodoroCount?: number\n}\n\nexport interface DailyStats {\n  id: string\n  userId: string\n  date: Date\n  totalStudyMinutes: number\n  taskCompleted: number\n  pomodoroCompleted: number\n  coursesStudied: string[]\n  productivityAvg?: number\n  streakDay: number\n}\n\nexport interface CourseGrade {\n  id: string\n  userId: string\n  courseName: string\n  courseCode?: string\n  credits?: number\n  color: string\n  icon?: string\n  grades: GradeEntry[]\n  currentGrade?: number // Calculated percentage\n  targetGrade?: number\n}\n\nexport interface GradeEntry {\n  id: string\n  name: string // \"Quiz 1\", \"Midterm\", \"Assignment 3\"\n  type: \"quiz\" | \"test\" | \"exam\" | \"assignment\" | \"project\" | \"participation\"\n  score: number\n  maxScore: number\n  weight: number // percentage weight in final grade\n  date: Date\n}\n\n// ==================== HABITS ====================\nexport interface Habit {\n  id: string\n  userId: string\n  name: string\n  description?: string\n  icon?: string\n  color: string\n  frequency: \"daily\" | \"weekly\" | \"custom\"\n  targetDays?: number[] // For weekly: which days (0-6)\n  targetCount?: number // Times per period\n  reminderTime?: string // \"08:00\"\n  currentStreak: number\n  longestStreak: number\n  completions: HabitCompletion[]\n  createdAt: Date\n  isArchived: boolean\n}\n\nexport interface HabitCompletion {\n  date: string // \"2025-12-23\"\n  completed: boolean\n  count?: number // For habits with multiple completions per day\n  notes?: string\n}\n\n// ==================== COURSES ====================\nexport interface Course {\n  id: string\n  userId: string\n  name: string\n  code?: string\n  professor?: string\n  color: string\n  icon?: string\n  credits?: number\n  schedule?: CourseSchedule[]\n  syllabus?: string[]\n  examDate?: Date\n  notes?: string\n}\n\nexport interface CourseSchedule {\n  dayOfWeek: number // 0-6\n  startTime: string // \"09:00\"\n  endTime: string // \"10:30\"\n  location?: string\n  type: \"lecture\" | \"lab\" | \"tutorial\" | \"office-hours\"\n}\n\n// Material Folder Functions\nexport async function getMaterialFolders(userId: string): Promise<MaterialFolder[]> {\n  const snapshot = await getDocs(collection(db, \"materialFolders\"))\n  const folders = snapshot.docs\n    .map(docSnap => {\n      const data = docSnap.data()\n      return {\n        id: docSnap.id,\n        ...data,\n        createdAt: data.createdAt?.toDate() || new Date()\n      } as MaterialFolder\n    })\n    .filter(f => f.userId === userId)\n  return folders.sort((a, b) => a.name.localeCompare(b.name))\n}\n\nexport async function createMaterialFolder(folder: Omit<MaterialFolder, \"id\" | \"createdAt\">): Promise<string> {\n  const docRef = await addDoc(collection(db, \"materialFolders\"), {\n    ...folder,\n    createdAt: serverTimestamp()\n  })\n  return docRef.id\n}\n\nexport async function deleteMaterialFolder(folderId: string): Promise<void> {\n  // Delete the folder\n  await deleteDoc(doc(db, \"materialFolders\", folderId))\n  // Move materials in this folder to root (remove folderId)\n  const snapshot = await getDocs(collection(db, \"materials\"))\n  const folderMaterials = snapshot.docs.filter(d => d.data().folderId === folderId)\n  for (const docSnap of folderMaterials) {\n    await updateDoc(docSnap.ref, { folderId: null })\n  }\n}\n\nexport async function updateMaterialFolder(materialId: string, folderId: string | null): Promise<void> {\n  await updateDoc(doc(db, \"materials\", materialId), { folderId })\n}\n\n// Materials Functions\nexport async function getMaterials(userId: string, folderId?: string | null): Promise<Material[]> {\n  // Fetch all and filter client-side to avoid index requirements\n  const snapshot = await getDocs(collection(db, \"materials\"))\n  let materials = snapshot.docs\n    .map(docSnap => {\n      const data = docSnap.data()\n      return {\n        id: docSnap.id,\n        ...data,\n        createdAt: data.createdAt?.toDate() || new Date()\n      } as Material\n    })\n    .filter(m => m.userId === userId)\n  \n  // Filter by folder if specified\n  if (folderId !== undefined) {\n    materials = materials.filter(m => (m.folderId || null) === folderId)\n  }\n  \n  return materials.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime())\n}\n\nexport async function addMaterial(material: Omit<Material, \"id\" | \"createdAt\">): Promise<string> {\n  const docRef = await addDoc(collection(db, \"materials\"), {\n    ...material,\n    createdAt: serverTimestamp()\n  })\n  return docRef.id\n}\n\nexport async function uploadFile(file: File, userId: string): Promise<string> {\n  const fileRef = ref(storage, `materials/${userId}/${Date.now()}_${file.name}`)\n  await uploadBytes(fileRef, file)\n  return getDownloadURL(fileRef)\n}\n\nexport async function deleteMaterial(materialId: string): Promise<void> {\n  await deleteDoc(doc(db, \"materials\", materialId))\n}\n\n// Flashcard Functions\nexport async function getFlashcardDecks(userId: string): Promise<FlashcardDeck[]> {\n  // Fetch all and filter client-side to avoid index requirements\n  const snapshot = await getDocs(collection(db, \"flashcardDecks\"))\n  const decks = snapshot.docs\n    .map(docSnap => {\n      const data = docSnap.data()\n      return {\n        id: docSnap.id,\n        ...data,\n        createdAt: data.createdAt?.toDate() || new Date()\n      } as FlashcardDeck\n    })\n    .filter(d => d.userId === userId)\n  return decks.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime())\n}\n\nexport async function createFlashcardDeck(deck: Omit<FlashcardDeck, \"id\" | \"createdAt\" | \"cardCount\">): Promise<string> {\n  const docRef = await addDoc(collection(db, \"flashcardDecks\"), {\n    ...deck,\n    cardCount: 0,\n    createdAt: serverTimestamp()\n  })\n  return docRef.id\n}\n\nexport async function getFlashcards(deckId: string): Promise<Flashcard[]> {\n  // Fetch all and filter client-side to avoid index requirements\n  const snapshot = await getDocs(collection(db, \"flashcards\"))\n  return snapshot.docs\n    .map(docSnap => ({ id: docSnap.id, ...docSnap.data() } as Flashcard))\n    .filter(c => c.deckId === deckId)\n}\n\nexport async function addFlashcard(card: Omit<Flashcard, \"id\" | \"createdAt\">): Promise<string> {\n  const docRef = await addDoc(collection(db, \"flashcards\"), {\n    ...card,\n    createdAt: new Date()\n  })\n  // Update deck card count\n  const deckRef = doc(db, \"flashcardDecks\", card.deckId)\n  const deckSnap = await getDoc(deckRef)\n  if (deckSnap.exists()) {\n    await updateDoc(deckRef, { cardCount: (deckSnap.data().cardCount || 0) + 1 })\n  }\n  return docRef.id\n}\n\n// Study Plans Functions\nexport async function getStudyPlans(userId: string): Promise<StudyPlan[]> {\n  const snapshot = await getDocs(collection(db, \"studyPlans\"))\n  const plans = snapshot.docs\n    .map(docSnap => {\n      const data = docSnap.data()\n      return {\n        id: docSnap.id,\n        ...data,\n        examDate: data.examDate?.toDate() || new Date(),\n        createdAt: data.createdAt?.toDate() || new Date()\n      } as StudyPlan\n    })\n    .filter(p => p.userId === userId)\n  return plans.sort((a, b) => a.examDate.getTime() - b.examDate.getTime())\n}\n\nexport async function createStudyPlan(plan: Omit<StudyPlan, \"id\" | \"createdAt\" | \"completedTasks\">): Promise<string> {\n  const docRef = await addDoc(collection(db, \"studyPlans\"), {\n    ...plan,\n    completedTasks: 0,\n    examDate: Timestamp.fromDate(plan.examDate),\n    createdAt: serverTimestamp()\n  })\n  \n  // After tasks are created, update the totalTasks count\n  return docRef.id\n}\n\nexport async function deleteStudyPlan(planId: string): Promise<void> {\n  // Delete the plan\n  await deleteDoc(doc(db, \"studyPlans\", planId))\n  // Delete all tasks associated with this plan\n  const snapshot = await getDocs(collection(db, \"studyTasks\"))\n  const planTasks = snapshot.docs.filter(d => d.data().planId === planId)\n  for (const docSnap of planTasks) {\n    await deleteDoc(docSnap.ref)\n  }\n}\n\nexport async function updatePlanProgress(planId: string, completedTasks: number): Promise<void> {\n  await updateDoc(doc(db, \"studyPlans\", planId), { completedTasks })\n}\n\nexport async function updatePlanTotalTasks(planId: string, totalTasks: number): Promise<void> {\n  await updateDoc(doc(db, \"studyPlans\", planId), { totalTasks })\n}\n\n// Study Tasks Functions\nexport async function getStudyTasks(userId: string, planId?: string): Promise<StudyTask[]> {\n  const snapshot = await getDocs(collection(db, \"studyTasks\"))\n  const tasks = snapshot.docs\n    .map(docSnap => {\n      const data = docSnap.data()\n      return {\n        id: docSnap.id,\n        ...data,\n        dueDate: data.dueDate?.toDate() || new Date(),\n        priority: data.priority || \"medium\",\n        status: data.status || \"pending\"\n      } as StudyTask\n    })\n    .filter(t => t.userId === userId && (!planId || t.planId === planId))\n  return tasks.sort((a, b) => a.day - b.day)\n}\n\nexport async function createStudyTask(task: Omit<StudyTask, \"id\" | \"completed\">): Promise<string> {\n  const docRef = await addDoc(collection(db, \"studyTasks\"), {\n    ...task,\n    completed: false,\n    dueDate: Timestamp.fromDate(task.dueDate)\n  })\n  return docRef.id\n}\n\nexport async function toggleTaskComplete(taskId: string, completed: boolean, planId?: string): Promise<void> {\n  await updateDoc(doc(db, \"studyTasks\", taskId), { completed })\n  \n  // Update plan progress if planId provided\n  if (planId) {\n    const snapshot = await getDocs(collection(db, \"studyTasks\"))\n    const planTasks = snapshot.docs.filter(d => d.data().planId === planId)\n    const completedCount = planTasks.filter(d => d.data().completed || (d.id === taskId && completed)).length\n    await updatePlanProgress(planId, completedCount)\n  }\n}\n\nexport async function deleteStudyTask(taskId: string): Promise<void> {\n  await deleteDoc(doc(db, \"studyTasks\", taskId))\n}\n\nexport async function clearPlanTasks(planId: string): Promise<void> {\n  const snapshot = await getDocs(collection(db, \"studyTasks\"))\n  const planTasks = snapshot.docs.filter(d => d.data().planId === planId)\n  for (const docSnap of planTasks) {\n    await deleteDoc(docSnap.ref)\n  }\n}\n\n// Study Groups Functions\nexport async function getStudyGroups(userId?: string): Promise<StudyGroup[]> {\n  const snapshot = await getDocs(collection(db, \"studyGroups\"))\n  let groups = snapshot.docs.map(doc => ({\n    id: doc.id,\n    ...doc.data(),\n    createdAt: doc.data().createdAt?.toDate() || new Date()\n  })) as StudyGroup[]\n\n  // Filter groups where user is a member if userId is provided\n  if (userId) {\n    groups = groups.filter(group =>\n      group.members.some((member: GroupMember) => member.userId === userId)\n    )\n  }\n\n  // Sort client-side to avoid index requirement\n  return groups.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime())\n}\n\nexport async function getStudyGroup(groupId: string): Promise<StudyGroup | null> {\n  const docSnap = await getDoc(doc(db, \"studyGroups\", groupId))\n  if (!docSnap.exists()) return null\n  return {\n    id: docSnap.id,\n    ...docSnap.data(),\n    createdAt: docSnap.data().createdAt?.toDate() || new Date()\n  } as StudyGroup\n}\n\nexport async function createStudyGroup(group: Omit<StudyGroup, \"id\" | \"createdAt\" | \"memberCount\">): Promise<string> {\n  const docRef = await addDoc(collection(db, \"studyGroups\"), {\n    ...group,\n    memberCount: group.members.length,\n    createdAt: serverTimestamp()\n  })\n  return docRef.id\n}\n\nexport async function joinGroup(groupId: string, member: GroupMember): Promise<void> {\n  const groupRef = doc(db, \"studyGroups\", groupId)\n  const groupSnap = await getDoc(groupRef)\n  if (groupSnap.exists()) {\n    const groupData = groupSnap.data()\n    const members = groupData.members || []\n\n    // Check if group is full\n    if (members.length >= (groupData.maxMembers || 10)) {\n      throw new Error(\"Group is full\")\n    }\n\n    if (!members.some((m: GroupMember) => m.userId === member.userId)) {\n      await updateDoc(groupRef, {\n        members: [...members, member],\n        memberCount: members.length + 1\n      })\n    }\n  }\n}\n\nexport async function leaveGroup(groupId: string, userId: string): Promise<void> {\n  const groupRef = doc(db, \"studyGroups\", groupId)\n  const groupSnap = await getDoc(groupRef)\n  if (groupSnap.exists()) {\n    const members = groupSnap.data().members || []\n    const newMembers = members.filter((m: string) => m !== userId)\n    await updateDoc(groupRef, {\n      members: newMembers,\n      memberCount: newMembers.length\n    })\n  }\n}\n\n// Group Messages Functions\nexport function subscribeToGroupMessages(\n  groupId: string, \n  callback: (messages: GroupMessage[]) => void\n): () => void {\n  // Subscribe to all messages and filter client-side to avoid index requirements\n  return onSnapshot(collection(db, \"groupMessages\"), (snapshot) => {\n    const messages = snapshot.docs\n      .map(docSnap => {\n        const data = docSnap.data()\n        return {\n          id: docSnap.id,\n          ...data,\n          createdAt: data.createdAt?.toDate() || new Date()\n        } as GroupMessage\n      })\n      .filter(m => m.groupId === groupId)\n    callback(messages.sort((a, b) => a.createdAt.getTime() - b.createdAt.getTime()))\n  })\n}\n\nexport async function sendGroupMessage(message: Omit<GroupMessage, \"id\" | \"createdAt\">): Promise<string> {\n  const docRef = await addDoc(collection(db, \"groupMessages\"), {\n    ...message,\n    createdAt: serverTimestamp()\n  })\n  return docRef.id\n}\n\n// Bookmarked Jobs Functions\nexport async function getBookmarkedJobs(userId: string): Promise<BookmarkedJob[]> {\n  // Fetch all and filter client-side to avoid index requirements\n  const snapshot = await getDocs(collection(db, \"bookmarkedJobs\"))\n  return snapshot.docs\n    .map(docSnap => {\n      const data = docSnap.data()\n      return {\n        id: docSnap.id,\n        ...data,\n        createdAt: data.createdAt?.toDate() || new Date()\n      } as BookmarkedJob\n    })\n    .filter(b => b.userId === userId)\n}\n\nexport async function toggleJobBookmark(job: Omit<BookmarkedJob, \"id\" | \"createdAt\">): Promise<boolean> {\n  // Fetch all and filter client-side to avoid index requirements\n  const snapshot = await getDocs(collection(db, \"bookmarkedJobs\"))\n  const existing = snapshot.docs.find(d => \n    d.data().userId === job.userId && d.data().jobId === job.jobId\n  )\n  \n  if (!existing) {\n    await addDoc(collection(db, \"bookmarkedJobs\"), {\n      ...job,\n      createdAt: serverTimestamp()\n    })\n    return true // Now bookmarked\n  } else {\n    await deleteDoc(existing.ref)\n    return false // Unbookmarked\n  }\n}\n\n// User Profile\nexport async function getUserProfile(userId: string) {\n  const docSnap = await getDoc(doc(db, \"users\", userId))\n  return docSnap.exists() ? docSnap.data() : null\n}\n\nexport async function updateUserProfile(userId: string, data: Record<string, unknown>) {\n  await setDoc(doc(db, \"users\", userId), data, { merge: true })\n}\n\n// ==================== CONVERSATION FUNCTIONS ====================\nexport async function getConversations(userId: string): Promise<Conversation[]> {\n  const snapshot = await getDocs(collection(db, \"conversations\"))\n  return snapshot.docs\n    .map(docSnap => {\n      const data = docSnap.data()\n      return {\n        id: docSnap.id,\n        ...data,\n        messages: (data.messages || []).map((m: any) => ({\n          ...m,\n          timestamp: m.timestamp?.toDate() || new Date()\n        })),\n        createdAt: data.createdAt?.toDate() || new Date(),\n        updatedAt: data.updatedAt?.toDate() || new Date()\n      } as Conversation\n    })\n    .filter(c => c.userId === userId)\n    .sort((a, b) => b.updatedAt.getTime() - a.updatedAt.getTime())\n}\n\nexport async function createConversation(userId: string, title: string = \"New Conversation\"): Promise<string> {\n  const docRef = await addDoc(collection(db, \"conversations\"), {\n    userId,\n    title,\n    messages: [],\n    createdAt: serverTimestamp(),\n    updatedAt: serverTimestamp()\n  })\n  return docRef.id\n}\n\nexport async function addMessageToConversation(\n  conversationId: string,\n  message: Omit<ConversationMessage, \"timestamp\">\n): Promise<void> {\n  const docRef = doc(db, \"conversations\", conversationId)\n  const docSnap = await getDoc(docRef)\n  \n  if (!docSnap.exists()) {\n    throw new Error(\"Conversation not found\")\n  }\n  \n  const data = docSnap.data()\n  const messages = data.messages || []\n  messages.push({\n    ...message,\n    timestamp: new Date()\n  })\n  \n  await updateDoc(docRef, {\n    messages,\n    updatedAt: serverTimestamp()\n  })\n}\n\nexport async function deleteConversation(conversationId: string): Promise<void> {\n  await deleteDoc(doc(db, \"conversations\", conversationId))\n}\n\nexport async function updateConversationTitle(conversationId: string, title: string): Promise<void> {\n  await updateDoc(doc(db, \"conversations\", conversationId), { title })\n}\n\n// ==================== MEMORY FUNCTIONS ====================\nexport async function getMemories(userId: string): Promise<Memory[]> {\n  const snapshot = await getDocs(collection(db, \"memories\"))\n  return snapshot.docs\n    .map(docSnap => {\n      const data = docSnap.data()\n      return {\n        id: docSnap.id,\n        ...data,\n        createdAt: data.createdAt?.toDate() || new Date()\n      } as Memory\n    })\n    .filter(m => m.userId === userId)\n    .sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime())\n}\n\nexport async function addMemory(memory: Omit<Memory, \"id\" | \"createdAt\">): Promise<string> {\n  const docRef = await addDoc(collection(db, \"memories\"), {\n    ...memory,\n    createdAt: serverTimestamp()\n  })\n  return docRef.id\n}\n\nexport async function deleteMemory(memoryId: string): Promise<void> {\n  await deleteDoc(doc(db, \"memories\", memoryId))\n}\n\nexport async function searchMemories(userId: string, query: string): Promise<Memory[]> {\n  const memories = await getMemories(userId)\n  const lowerQuery = query.toLowerCase()\n  return memories.filter(m => \n    m.content.toLowerCase().includes(lowerQuery)\n  )\n}\n\n// ==================== TASK FUNCTIONS ====================\nexport async function getTasks(userId: string, filters?: {\n  status?: Task[\"status\"]\n  priority?: Task[\"priority\"]\n  course?: string\n  tag?: string\n  dateRange?: { start: Date; end: Date }\n}): Promise<Task[]> {\n  const snapshot = await getDocs(collection(db, \"tasks\"))\n  let tasks = snapshot.docs\n    .map(docSnap => {\n      const data = docSnap.data()\n      return {\n        id: docSnap.id,\n        ...data,\n        dueDate: data.dueDate?.toDate(),\n        scheduledDate: data.scheduledDate?.toDate(),\n        completedAt: data.completedAt?.toDate(),\n        createdAt: data.createdAt?.toDate() || new Date(),\n        updatedAt: data.updatedAt?.toDate() || new Date(),\n        subtasks: data.subtasks || [],\n        tags: data.tags || [],\n        links: data.links || []\n      } as Task\n    })\n    .filter(t => t.userId === userId)\n\n  if (filters?.status) tasks = tasks.filter(t => t.status === filters.status)\n  if (filters?.priority) tasks = tasks.filter(t => t.priority === filters.priority)\n  if (filters?.course) tasks = tasks.filter(t => t.course === filters.course)\n  if (filters?.tag) tasks = tasks.filter(t => t.tags.includes(filters.tag!))\n  if (filters?.dateRange) {\n    tasks = tasks.filter(t => \n      t.dueDate && t.dueDate >= filters.dateRange!.start && t.dueDate <= filters.dateRange!.end\n    )\n  }\n\n  return tasks.sort((a, b) => {\n    const priorityOrder = { urgent: 0, high: 1, medium: 2, low: 3 }\n    return priorityOrder[a.priority] - priorityOrder[b.priority]\n  })\n}\n\nexport async function createTask(task: Omit<Task, \"id\" | \"createdAt\" | \"updatedAt\">): Promise<string> {\n  const docRef = await addDoc(collection(db, \"tasks\"), {\n    ...task,\n    createdAt: serverTimestamp(),\n    updatedAt: serverTimestamp()\n  })\n  return docRef.id\n}\n\nexport async function updateTask(taskId: string, updates: Partial<Task>): Promise<void> {\n  await updateDoc(doc(db, \"tasks\", taskId), {\n    ...updates,\n    updatedAt: serverTimestamp()\n  })\n}\n\nexport async function deleteTask(taskId: string): Promise<void> {\n  await deleteDoc(doc(db, \"tasks\", taskId))\n}\n\nexport async function toggleSubtask(taskId: string, subtaskId: string): Promise<void> {\n  const docRef = doc(db, \"tasks\", taskId)\n  const docSnap = await getDoc(docRef)\n  if (!docSnap.exists()) return\n\n  const task = docSnap.data()\n  const subtasks = task.subtasks || []\n  const updatedSubtasks = subtasks.map((st: Subtask) =>\n    st.id === subtaskId ? { ...st, completed: !st.completed } : st\n  )\n\n  await updateDoc(docRef, { subtasks: updatedSubtasks, updatedAt: serverTimestamp() })\n}\n\n// ==================== CALENDAR EVENT FUNCTIONS ====================\nexport async function getCalendarEvents(userId: string, dateRange?: { start: Date; end: Date }): Promise<CalendarEvent[]> {\n  const snapshot = await getDocs(collection(db, \"calendarEvents\"))\n  let events = snapshot.docs\n    .map(docSnap => {\n      const data = docSnap.data()\n      return {\n        id: docSnap.id,\n        ...data,\n        startTime: data.startTime?.toDate() || new Date(),\n        endTime: data.endTime?.toDate() || new Date(),\n        createdAt: data.createdAt?.toDate() || new Date(),\n        recurrence: data.recurrence ? {\n          ...data.recurrence,\n          endDate: data.recurrence.endDate?.toDate(),\n          exceptions: data.recurrence.exceptions?.map((e: any) => e.toDate()) || []\n        } : undefined\n      } as CalendarEvent\n    })\n    .filter(e => e.userId === userId)\n\n  if (dateRange) {\n    events = events.filter(e => \n      e.startTime >= dateRange.start && e.startTime <= dateRange.end\n    )\n  }\n\n  return events.sort((a, b) => a.startTime.getTime() - b.startTime.getTime())\n}\n\nexport async function createCalendarEvent(event: Omit<CalendarEvent, \"id\" | \"createdAt\">): Promise<string> {\n  const docRef = await addDoc(collection(db, \"calendarEvents\"), {\n    ...event,\n    createdAt: serverTimestamp()\n  })\n  return docRef.id\n}\n\nexport async function updateCalendarEvent(eventId: string, updates: Partial<CalendarEvent>): Promise<void> {\n  await updateDoc(doc(db, \"calendarEvents\", eventId), updates)\n}\n\nexport async function deleteCalendarEvent(eventId: string): Promise<void> {\n  await deleteDoc(doc(db, \"calendarEvents\", eventId))\n}\n\n// ==================== POMODORO FUNCTIONS ====================\nexport async function getPomodoroSettings(userId: string): Promise<PomodoroSettings | null> {\n  const docSnap = await getDoc(doc(db, \"pomodoroSettings\", userId))\n  return docSnap.exists() ? docSnap.data() as PomodoroSettings : null\n}\n\nexport async function savePomodoroSettings(settings: PomodoroSettings): Promise<void> {\n  await setDoc(doc(db, \"pomodoroSettings\", settings.userId), settings)\n}\n\nexport async function logPomodoroSession(session: Omit<PomodoroSession, \"id\">): Promise<string> {\n  const docRef = await addDoc(collection(db, \"pomodoroSessions\"), session)\n  return docRef.id\n}\n\nexport async function getPomodoroSessions(userId: string, dateRange?: { start: Date; end: Date }): Promise<PomodoroSession[]> {\n  const snapshot = await getDocs(collection(db, \"pomodoroSessions\"))\n  let sessions = snapshot.docs\n    .map(docSnap => {\n      const data = docSnap.data()\n      return {\n        id: docSnap.id,\n        ...data,\n        startTime: data.startTime?.toDate() || new Date(),\n        endTime: data.endTime?.toDate()\n      } as PomodoroSession\n    })\n    .filter(s => s.userId === userId)\n\n  if (dateRange) {\n    sessions = sessions.filter(s => \n      s.startTime >= dateRange.start && s.startTime <= dateRange.end\n    )\n  }\n\n  return sessions.sort((a, b) => b.startTime.getTime() - a.startTime.getTime())\n}\n\n// ==================== STUDY SESSION & ANALYTICS FUNCTIONS ====================\nexport async function logStudySession(session: Omit<StudySession, \"id\">): Promise<string> {\n  const docRef = await addDoc(collection(db, \"studySessions\"), session)\n  \n  // Update daily stats\n  const dateStr = session.startTime.toISOString().split('T')[0]\n  await updateDailyStats(session.userId, dateStr, session.duration, session.course)\n  \n  return docRef.id\n}\n\nexport async function getStudySessions(userId: string, dateRange?: { start: Date; end: Date }): Promise<StudySession[]> {\n  const snapshot = await getDocs(collection(db, \"studySessions\"))\n  let sessions = snapshot.docs\n    .map(docSnap => {\n      const data = docSnap.data()\n      return {\n        id: docSnap.id,\n        ...data,\n        startTime: data.startTime?.toDate() || new Date(),\n        endTime: data.endTime?.toDate() || new Date(),\n        tags: data.tags || []\n      } as StudySession\n    })\n    .filter(s => s.userId === userId)\n\n  if (dateRange) {\n    sessions = sessions.filter(s => \n      s.startTime >= dateRange.start && s.startTime <= dateRange.end\n    )\n  }\n\n  return sessions.sort((a, b) => b.startTime.getTime() - a.startTime.getTime())\n}\n\nexport async function getDailyStats(userId: string, date: string): Promise<DailyStats | null> {\n  const docSnap = await getDoc(doc(db, \"dailyStats\", `${userId}_${date}`))\n  if (!docSnap.exists()) return null\n  const data = docSnap.data()\n  return {\n    id: docSnap.id,\n    ...data,\n    date: data.date?.toDate() || new Date(),\n    coursesStudied: data.coursesStudied || []\n  } as DailyStats\n}\n\nexport async function getWeeklyStats(userId: string): Promise<DailyStats[]> {\n  const today = new Date()\n  const weekAgo = new Date(today)\n  weekAgo.setDate(weekAgo.getDate() - 7)\n  \n  const stats: DailyStats[] = []\n  for (let d = new Date(weekAgo); d <= today; d.setDate(d.getDate() + 1)) {\n    const dateStr = d.toISOString().split('T')[0]\n    const dayStat = await getDailyStats(userId, dateStr)\n    if (dayStat) stats.push(dayStat)\n  }\n  return stats\n}\n\nasync function updateDailyStats(userId: string, dateStr: string, minutes: number, course?: string): Promise<void> {\n  const docRef = doc(db, \"dailyStats\", `${userId}_${dateStr}`)\n  const existing = await getDoc(docRef)\n  \n  if (existing.exists()) {\n    const data = existing.data()\n    const coursesStudied = data.coursesStudied || []\n    if (course && !coursesStudied.includes(course)) {\n      coursesStudied.push(course)\n    }\n    await updateDoc(docRef, {\n      totalStudyMinutes: (data.totalStudyMinutes || 0) + minutes,\n      coursesStudied\n    })\n  } else {\n    // Calculate streak\n    const yesterday = new Date(dateStr)\n    yesterday.setDate(yesterday.getDate() - 1)\n    const yesterdayStats = await getDailyStats(userId, yesterday.toISOString().split('T')[0])\n    const streakDay = yesterdayStats ? yesterdayStats.streakDay + 1 : 1\n    \n    await setDoc(docRef, {\n      userId,\n      date: new Date(dateStr),\n      totalStudyMinutes: minutes,\n      taskCompleted: 0,\n      pomodoroCompleted: 0,\n      coursesStudied: course ? [course] : [],\n      streakDay\n    })\n  }\n}\n\n// ==================== COURSE & GRADE FUNCTIONS ====================\nexport async function getCourses(userId: string): Promise<Course[]> {\n  const snapshot = await getDocs(collection(db, \"courses\"))\n  return snapshot.docs\n    .map(docSnap => {\n      const data = docSnap.data()\n      return {\n        id: docSnap.id,\n        ...data,\n        schedule: data.schedule || [],\n        examDate: data.examDate?.toDate()\n      } as Course\n    })\n    .filter(c => c.userId === userId)\n}\n\nexport async function createCourse(course: Omit<Course, \"id\">): Promise<string> {\n  const docRef = await addDoc(collection(db, \"courses\"), course)\n  return docRef.id\n}\n\nexport async function updateCourse(courseId: string, updates: Partial<Course>): Promise<void> {\n  await updateDoc(doc(db, \"courses\", courseId), updates)\n}\n\nexport async function deleteCourse(courseId: string): Promise<void> {\n  await deleteDoc(doc(db, \"courses\", courseId))\n}\n\nexport async function getCourseGrades(userId: string): Promise<CourseGrade[]> {\n  const snapshot = await getDocs(collection(db, \"courseGrades\"))\n  return snapshot.docs\n    .map(docSnap => {\n      const data = docSnap.data()\n      return {\n        id: docSnap.id,\n        ...data,\n        grades: (data.grades || []).map((g: any) => ({\n          ...g,\n          date: g.date?.toDate() || new Date()\n        }))\n      } as CourseGrade\n    })\n    .filter(g => g.userId === userId)\n}\n\nexport async function addGradeEntry(courseGradeId: string, entry: Omit<GradeEntry, \"id\">): Promise<void> {\n  const docRef = doc(db, \"courseGrades\", courseGradeId)\n  const docSnap = await getDoc(docRef)\n  if (!docSnap.exists()) return\n\n  const data = docSnap.data()\n  const grades = data.grades || []\n  grades.push({ ...entry, id: Date.now().toString() })\n\n  // Calculate current grade\n  const totalWeight = grades.reduce((sum: number, g: GradeEntry) => sum + g.weight, 0)\n  const weightedScore = grades.reduce((sum: number, g: GradeEntry) => \n    sum + (g.score / g.maxScore * 100) * (g.weight / 100), 0\n  )\n  const currentGrade = totalWeight > 0 ? (weightedScore / totalWeight) * 100 : 0\n\n  await updateDoc(docRef, { grades, currentGrade })\n}\n\n// ==================== HABIT FUNCTIONS ====================\nexport async function getHabits(userId: string): Promise<Habit[]> {\n  const snapshot = await getDocs(collection(db, \"habits\"))\n  return snapshot.docs\n    .map(docSnap => {\n      const data = docSnap.data()\n      return {\n        id: docSnap.id,\n        ...data,\n        createdAt: data.createdAt?.toDate() || new Date(),\n        completions: data.completions || []\n      } as Habit\n    })\n    .filter(h => h.userId === userId && !h.isArchived)\n}\n\nexport async function createHabit(habit: Omit<Habit, \"id\" | \"createdAt\" | \"currentStreak\" | \"longestStreak\" | \"completions\">): Promise<string> {\n  const docRef = await addDoc(collection(db, \"habits\"), {\n    ...habit,\n    currentStreak: 0,\n    longestStreak: 0,\n    completions: [],\n    createdAt: serverTimestamp()\n  })\n  return docRef.id\n}\n\nexport async function toggleHabitCompletion(habitId: string, date: string): Promise<void> {\n  const docRef = doc(db, \"habits\", habitId)\n  const docSnap = await getDoc(docRef)\n  if (!docSnap.exists()) return\n\n  const habit = docSnap.data()\n  const completions = habit.completions || []\n  const existingIdx = completions.findIndex((c: HabitCompletion) => c.date === date)\n\n  if (existingIdx >= 0) {\n    completions[existingIdx].completed = !completions[existingIdx].completed\n  } else {\n    completions.push({ date, completed: true })\n  }\n\n  // Calculate streak\n  let streak = 0\n  const today = new Date()\n  for (let i = 0; i < 365; i++) {\n    const checkDate = new Date(today)\n    checkDate.setDate(checkDate.getDate() - i)\n    const dateStr = checkDate.toISOString().split('T')[0]\n    const completion = completions.find((c: HabitCompletion) => c.date === dateStr)\n    if (completion?.completed) {\n      streak++\n    } else if (i > 0) { // Allow today to be incomplete\n      break\n    }\n  }\n\n  const longestStreak = Math.max(habit.longestStreak || 0, streak)\n\n  await updateDoc(docRef, { completions, currentStreak: streak, longestStreak })\n}\n\nexport async function deleteHabit(habitId: string): Promise<void> {\n  await updateDoc(doc(db, \"habits\", habitId), { isArchived: true })\n}\n\n// ==================== TIME BLOCK FUNCTIONS ====================\nexport async function getTimeBlocks(userId: string, date: Date): Promise<TimeBlock[]> {\n  const startOfDay = new Date(date)\n  startOfDay.setHours(0, 0, 0, 0)\n  const endOfDay = new Date(date)\n  endOfDay.setHours(23, 59, 59, 999)\n\n  const snapshot = await getDocs(collection(db, \"timeBlocks\"))\n  return snapshot.docs\n    .map(docSnap => {\n      const data = docSnap.data()\n      return {\n        id: docSnap.id,\n        ...data,\n        startTime: data.startTime?.toDate() || new Date(),\n        endTime: data.endTime?.toDate() || new Date(),\n        createdAt: data.createdAt?.toDate() || new Date()\n      } as TimeBlock\n    })\n    .filter(tb => \n      tb.userId === userId && \n      tb.startTime >= startOfDay && \n      tb.startTime <= endOfDay\n    )\n    .sort((a, b) => a.startTime.getTime() - b.startTime.getTime())\n}\n\nexport async function createTimeBlock(block: Omit<TimeBlock, \"id\" | \"createdAt\">): Promise<string> {\n  const docRef = await addDoc(collection(db, \"timeBlocks\"), {\n    ...block,\n    createdAt: serverTimestamp()\n  })\n  return docRef.id\n}\n\nexport async function updateTimeBlock(blockId: string, updates: Partial<TimeBlock>): Promise<void> {\n  await updateDoc(doc(db, \"timeBlocks\", blockId), updates)\n}\n\nexport async function deleteTimeBlock(blockId: string): Promise<void> {\n  await deleteDoc(doc(db, \"timeBlocks\", blockId))\n}\n\n// ==================== FLASHCARDS ====================\nexport async function createFlashcards(\n  userId: string,\n  cards: Omit<Flashcard, \"id\" | \"userId\" | \"createdAt\">[],\n): Promise<Flashcard[]> {\n  const flashcardsRef = collection(db, \"flashcards\")\n  const createdCards: Flashcard[] = []\n\n  for (const cardData of cards) {\n    const docRef = doc(flashcardsRef)\n    const card: Flashcard = {\n      id: docRef.id,\n      userId,\n      ...cardData,\n      createdAt: new Date(),\n    }\n    await setDoc(docRef, card)\n    createdCards.push(card)\n  }\n\n  return createdCards\n}\n\n// ==================== USER DATA AGGREGATION ====================\nexport async function getUserData(userId: string): Promise<{\n  tasks: Task[]\n  courses: Course[]\n  habits: Habit[]\n  dailyStats: DailyStats | null\n  userStreak: number\n}> {\n  const [tasks, courses, habits] = await Promise.all([\n    getTasks(userId),\n    getCourses(userId),\n    getHabits(userId)\n  ])\n\n  // Get today's stats\n  const today = new Date().toISOString().split('T')[0]\n  const dailyStats = await getDailyStats(userId, today)\n\n  // Calculate user streak (simplified - could be more sophisticated)\n  let userStreak = 0\n  if (dailyStats) {\n    userStreak = dailyStats.streakDay\n  }\n\n  return {\n    tasks,\n    courses,\n    habits,\n    dailyStats,\n    userStreak\n  }\n}"],"names":[],"mappings":"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"}